#pragma once

#include "Definitions.h"
#include "MapDefinitions.h"

class CMapHandler
{
private:
	ICamera* mpMapCam; //The camera used to view the map.
	IMesh* mpGridSpaceMesh; //The mesh for the model that represents the grid.
	IModel* mpBackground; //The mBackground model.

	//The start and end positions for the pathfinding
	SIntVector mStartNode;
	SIntVector mEndNode;

	SIntVector mDimensions = { 0, 0 }; //The dimensions of the map in use.

	GridVisual mMapVisual; //The physical representation of the grid;
	vector<IModel*> mSearchOverlay; //Models placed over the grid to show the progress of the search.

	string mMapSelected; //The map in use. If empty, a map has not been loaded.
	ESearchType mSearchSelected = ESearchType::NumOfSearches; //The search in use. If "NumOfSearches" (A non-option included for cycling), a selection hasn't been made.
public:
	TerrainMap mMapData; //2D array, square, of map data.

	//These NodeLists are used to keep track of the respective lists while stepping through a search.
	NodeList mOpenList;
	NodeList mClosedList;
	unique_ptr<SNode> mpGoal; //To avoid re-declaring the goal every loop.

	//When the Map Handler is created, create the camera and models.
	//Scale down the models so that it fits a model per unit square.
	CMapHandler(I3DEngine* myEngine);

	//Setters and getters
	//When setting the start and end nodes, change the texture of the current node before changing the texture of the new node.
	void SetStartNode(const SIntVector &coords);
	SIntVector GetStartNode();
	void SetEndNode(const SIntVector &coords);
	SIntVector GetEndNode();
	SIntVector GetDimensions();
	CVector3 GetNodePosition(const int &x, const int &z);
	void SetSearchSelection(const short &selection);
	ESearchType GetSearchSelection();

	IModel* BuildFromGridspaceMesh(CVector3 position);

	//Tests if a map has been selected.
	bool MapSelected();

	//Convert the coordinates for a node into the index for the mMapVisual vector.
	int NodeIndex(SIntVector node);
	int NodeIndex(int x, int z);

	/** Camera Controls **/
	void ZoomCamOut(float frameTime);
	void ZoomCamIn(float frameTime);

	/** Set up the map display (physical and texture) **/
	//Create enough models to display the  grid
	void SetupGrid();
	
	//Set the textures of the models used to display the map.
	void SetupTerrain();

	/** Path/Search demonstration manipulation **/
	//If there aren't enough models available to demonstrate the search, push more onto the end.
	//Loop through openlist and closedlist, place them just above the nodes in the list and apply the relevant textures.
	void SetupSearchDemo();

	//If the first overlay isn't at the spawn position, set all overlays to the spawn position.
	void HideSearchDemo();

	/** File input and output **/
	//Take user input for file name and check for a map file.
	void ReadMap();

	//Take the path generated by the search and output it to a file.
	void SaveResultsToFile(NodeList &path);
};

class CBallHandler
{
private:
	IModel* mpBody;
	CVector3 mPosition;
	CVector3 mRollDirection;
	CMatrix4x4 mMatrix;
	int mCycler; //The value used to cycle through the path deque.
	vector<CVector3> mPath; //The route from start to goal that the ball will follow.
	EBallState mState;

	vector<IModel*> mPathOverlay; //Models placed over the grid to roughly show the path the ball will follow.

public:

	CBallHandler(IMesh* mesh);

	/** These functions allow the program to interact with the private member variables. **/
	// Set the ball's model matrix to the member matrix.
	void SetModelMatrix();

	// Takes the generated path and a reference to the map and converts it into coordinates.
	void SetPath(NodeList &searchResult, CMapHandler* map);


	void SetupPathOverlay(NodeList &searchResult, CMapHandler* map);

	//If the first overlay isn't at the spawn position, set all overlays to the spawn position.
	void HidePathDemo();

	//Performs a Bezier spline using 0.2 increments.
	void BezierSpline(CVector3 p1, CVector3 p2, CVector3 p3, CVector3 p4, //Indexes of the points on the path to use for the calculation.
					  CVector3 &s1, CVector3 &s2, CVector3 &s3);

	//Sets the Y coordinate to below the mBackground to hide it.
	void HideBall();

	//Place the ball at the Startnode and point it towards the north.
	void SpawnBall();

	//Rotate the facing vector towards the next position to move towards.
	void PointAtNode(CVector3 modTarget);

	//Raise the ball up through the grid into view, then roll the ball across the path, then sink the ball through the grid when it reaches the goal.
	void MoveBall(const float &frameTime);

	//Length for X and Z only. 2D movement.
	float XZLength(const CVector3& v);
};